-- MySQL dump 10.13  Distrib 5.7.16, for Linux (x86_64)
--
-- Host: localhost    Database: wiki
-- ------------------------------------------------------
-- Server version	5.7.16-0ubuntu0.16.04.1

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `notes`
--

DROP TABLE IF EXISTS `notes`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `notes` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `pid` int(11) NOT NULL DEFAULT '0',
  `title` varchar(200) NOT NULL DEFAULT '',
  `content` text,
  `type` tinyint(4) NOT NULL DEFAULT '0',
  `created_at` int(11) DEFAULT '0',
  `updated_at` int(11) DEFAULT '0',
  `sort` int(11) DEFAULT '0',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=34 DEFAULT CHARSET=utf8 COMMENT='笔记';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `notes`
--

LOCK TABLES `notes` WRITE;
/*!40000 ALTER TABLE `notes` DISABLE KEYS */;
INSERT INTO `notes` VALUES (1,0,'PHP 编程',NULL,1,0,0,0),(2,0,'WEB 前端',NULL,1,0,0,0),(3,0,'数据库',NULL,1,0,0,0),(4,0,'Linux 运维',NULL,1,0,0,0),(5,1,'框架',NULL,1,1494140518,1494140518,0),(6,5,'Phalcon',NULL,1,1494140568,1494140568,0),(7,5,'Laravel',NULL,1,1494140576,1494140576,0),(8,5,'ThinkPHP',NULL,1,1494140587,1494140587,0),(10,1,'Awesome PHP',NULL,1,1494738544,1494738544,0),(11,1,'PHP Manual',NULL,1,1495640331,1495640331,0),(12,6,'01目录','# marked\n\n> A full-featured markdown parser and compiler, written in JavaScript. Built\n> for speed.\n\n[![NPM version](https://badge.fury.io/js/marked.png)][badge]\n\n## Install\n\n``` bash\nnpm install marked --save\n```\n\n## Usage\n\nMinimal usage:\n\n```js\nvar marked = require(\'marked\');\nconsole.log(marked(\'I am using __markdown__.\'));\n// Outputs: <p>I am using <strong>markdown</strong>.</p>\n```\n\nExample setting options with default values:\n\n```js\nvar marked = require(\'marked\');\nmarked.setOptions({\n  renderer: new marked.Renderer(),\n  gfm: true,\n  tables: true,\n  breaks: false,\n  pedantic: false,\n  sanitize: false,\n  smartLists: true,\n  smartypants: false\n});\n\nconsole.log(marked(\'I am using __markdown__.\'));\n```\n\n### Browser\n\n```html\n<!doctype html>\n<html>\n<head>\n  <meta charset=\"utf-8\"/>\n  <title>Marked in the browser</title>\n  <script src=\"lib/marked.js\"></script>\n</head>\n<body>\n  <div id=\"content\"></div>\n  <script>\n    document.getElementById(\'content\').innerHTML =\n      marked(\'# Marked in browser\\n\\nRendered by **marked**.\');\n  </script>\n</body>\n</html>\n```\n\n## marked(markdownString [,options] [,callback])\n\n### markdownString\n\nType: `string`\n\nString of markdown source to be compiled.\n\n### options\n\nType: `object`\n\nHash of options. Can also be set using the `marked.setOptions` method as seen\nabove.\n\n### callback\n\nType: `function`\n\nFunction called when the `markdownString` has been fully parsed when using\nasync highlighting. If the `options` argument is omitted, this can be used as\nthe second argument.\n\n## Options\n\n### highlight\n\nType: `function`\n\nA function to highlight code blocks. The first example below uses async highlighting with\n[node-pygmentize-bundled][pygmentize], and the second is a synchronous example using\n[highlight.js][highlight]:\n\n```js\nvar marked = require(\'marked\');\n\nvar markdownString = \'```js\\n console.log(\"hello\"); \\n```\';\n\n// Async highlighting with pygmentize-bundled\nmarked.setOptions({\n  highlight: function (code, lang, callback) {\n    require(\'pygmentize-bundled\')({ lang: lang, format: \'html\' }, code, function (err, result) {\n      callback(err, result.toString());\n    });\n  }\n});\n\n// Using async version of marked\nmarked(markdownString, function (err, content) {\n  if (err) throw err;\n  console.log(content);\n});\n\n// Synchronous highlighting with highlight.js\nmarked.setOptions({\n  highlight: function (code) {\n    return require(\'highlight.js\').highlightAuto(code).value;\n  }\n});\n\nconsole.log(marked(markdownString));\n```\n\n#### highlight arguments\n\n`code`\n\nType: `string`\n\nThe section of code to pass to the highlighter.\n\n`lang`\n\nType: `string`\n\nThe programming language specified in the code block.\n\n`callback`\n\nType: `function`\n\nThe callback function to call when using an async highlighter.\n\n### renderer\n\nType: `object`\nDefault: `new Renderer()`\n\nAn object containing functions to render tokens to HTML.\n\n#### Overriding renderer methods\n\nThe renderer option allows you to render tokens in a custom manner. Here is an\nexample of overriding the default heading token rendering by adding an embedded anchor tag like on GitHub:\n\n```javascript\nvar marked = require(\'marked\');\nvar renderer = new marked.Renderer();\n\nrenderer.heading = function (text, level) {\n  var escapedText = text.toLowerCase().replace(/[^\\w]+/g, \'-\');\n\n  return \'<h\' + level + \'><a name=\"\' +\n                escapedText +\n                 \'\" class=\"anchor\" href=\"#\' +\n                 escapedText +\n                 \'\"><span class=\"header-link\"></span></a>\' +\n                  text + \'</h\' + level + \'>\';\n},\n\nconsole.log(marked(\'# heading+\', { renderer: renderer }));\n```\nThis code will output the following HTML:\n```html\n<h1>\n  <a name=\"heading-\" class=\"anchor\" href=\"#heading-\">\n    <span class=\"header-link\"></span>\n  </a>\n  heading+\n</h1>\n```\n\n#### Block level renderer methods\n\n- code(*string* code, *string* language)\n- blockquote(*string* quote)\n- html(*string* html)\n- heading(*string* text, *number*  level)\n- hr()\n- list(*string* body, *boolean* ordered)\n- listitem(*string*  text)\n- paragraph(*string* text)\n- table(*string* header, *string* body)\n- tablerow(*string* content)\n- tablecell(*string* content, *object* flags)\n\n`flags` has the following properties:\n\n```js\n{\n    header: true || false,\n    align: \'center\' || \'left\' || \'right\'\n}\n```\n\n#### Inline level renderer methods\n\n- strong(*string* text)\n- em(*string* text)\n- codespan(*string* code)\n- br()\n- del(*string* text)\n- link(*string* href, *string* title, *string* text)\n- image(*string* href, *string* title, *string* text)\n\n### gfm\n\nType: `boolean`\nDefault: `true`\n\nEnable [GitHub flavored markdown][gfm].\n\n### tables\n\nType: `boolean`\nDefault: `true`\n\nEnable GFM [tables][tables].\nThis option requires the `gfm` option to be true.\n\n### breaks\n\nType: `boolean`\nDefault: `false`\n\nEnable GFM [line breaks][breaks].\nThis option requires the `gfm` option to be true.\n\n### pedantic\n\nType: `boolean`\nDefault: `false`\n\nConform to obscure parts of `markdown.pl` as much as possible. Don\'t fix any of\nthe original markdown bugs or poor behavior.\n\n### sanitize\n\nType: `boolean`\nDefault: `false`\n\nSanitize the output. Ignore any HTML that has been input.\n\n### smartLists\n\nType: `boolean`\nDefault: `true`\n\nUse smarter list behavior than the original markdown. May eventually be\ndefault with the old behavior moved into `pedantic`.\n\n### smartypants\n\nType: `boolean`\nDefault: `false`\n\nUse \"smart\" typograhic punctuation for things like quotes and dashes.\n\n## Access to lexer and parser\n\nYou also have direct access to the lexer and parser if you so desire.\n\n``` js\nvar tokens = marked.lexer(text, options);\nconsole.log(marked.parser(tokens));\n```\n\n``` js\nvar lexer = new marked.Lexer(options);\nvar tokens = lexer.lex(text);\nconsole.log(tokens);\nconsole.log(lexer.rules);\n```\n\n## CLI\n\n``` bash\n$ marked -o hello.html\nhello world\n^D\n$ cat hello.html\n<p>hello world</p>\n```\n\n## Philosophy behind marked\n\nThe point of marked was to create a markdown compiler where it was possible to\nfrequently parse huge chunks of markdown without having to worry about\ncaching the compiled output somehow...or blocking for an unnecesarily long time.\n\nmarked is very concise and still implements all markdown features. It is also\nnow fully compatible with the client-side.\n\nmarked more or less passes the official markdown test suite in its\nentirety. This is important because a surprising number of markdown compilers\ncannot pass more than a few tests. It was very difficult to get marked as\ncompliant as it is. It could have cut corners in several areas for the sake\nof performance, but did not in order to be exactly what you expect in terms\nof a markdown rendering. In fact, this is why marked could be considered at a\ndisadvantage in the benchmarks above.\n\nAlong with implementing every markdown feature, marked also implements [GFM\nfeatures][gfmf].\n\n## Benchmarks\n\nnode v0.8.x\n\n``` bash\n$ node test --bench\nmarked completed in 3411ms.\nmarked (gfm) completed in 3727ms.\nmarked (pedantic) completed in 3201ms.\nrobotskirt completed in 808ms.\nshowdown (reuse converter) completed in 11954ms.\nshowdown (new converter) completed in 17774ms.\nmarkdown-js completed in 17191ms.\n```\n\n__Marked is now faster than Discount, which is written in C.__\n\nFor those feeling skeptical: These benchmarks run the entire markdown test suite 1000 times. The test suite tests every feature. It doesn\'t cater to specific aspects.\n\n### Pro level\n\nYou also have direct access to the lexer and parser if you so desire.\n\n``` js\nvar tokens = marked.lexer(text, options);\nconsole.log(marked.parser(tokens));\n```\n\n``` js\nvar lexer = new marked.Lexer(options);\nvar tokens = lexer.lex(text);\nconsole.log(tokens);\nconsole.log(lexer.rules);\n```\n\n``` bash\n$ node\n> require(\'marked\').lexer(\'> i am using marked.\')\n[ { type: \'blockquote_start\' },\n  { type: \'paragraph\',\n    text: \'i am using marked.\' },\n  { type: \'blockquote_end\' },\n  links: {} ]\n```\n\n## Running Tests & Contributing\n\nIf you want to submit a pull request, make sure your changes pass the test\nsuite. If you\'re adding a new feature, be sure to add your own test.\n\nThe marked test suite is set up slightly strangely: `test/new` is for all tests\nthat are not part of the original markdown.pl test suite (this is where your\ntest should go if you make one). `test/original` is only for the original\nmarkdown.pl tests. `test/tests` houses both types of tests after they have been\ncombined and moved/generated by running `node test --fix` or `marked --test\n--fix`.\n\nIn other words, if you have a test to add, add it to `test/new/` and then\nregenerate the tests with `node test --fix`. Commit the result. If your test\nuses a certain feature, for example, maybe it assumes GFM is *not* enabled, you\ncan add `.nogfm` to the filename. So, `my-test.text` becomes\n`my-test.nogfm.text`. You can do this with any marked option. Say you want\nline breaks and smartypants enabled, your filename should be:\n`my-test.breaks.smartypants.text`.\n\nTo run the tests:\n\n``` bash\ncd marked/\nnode test\n```\n\n### Contribution and License Agreement\n\nIf you contribute code to this project, you are implicitly allowing your code\nto be distributed under the MIT license. You are also implicitly verifying that\nall code is your original work. `</legalese>`\n\n## License\n\nCopyright (c) 2011-2014, Christopher Jeffrey. (MIT License)\n\nSee LICENSE for more info.\n\n[gfm]: https://help.github.com/articles/github-flavored-markdown\n[gfmf]: http://github.github.com/github-flavored-markdown/\n[pygmentize]: https://github.com/rvagg/node-pygmentize-bundled\n[highlight]: https://github.com/isagalaev/highlight.js\n[badge]: http://badge.fury.io/js/marked\n[tables]: https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet#wiki-tables\n[breaks]: https://help.github.com/articles/github-flavored-markdown#newlines',0,1497169006,1497169006,0),(13,6,'命名空间','# 命名空间 namespace\n\n[toc]\n\n## 第1节 命名空间概述\n### 1.1 什么是命名空间\n广义上讲，命名空间是一种封装事物的方法，是一个抽象的概念。具体来讲，如操作系统中的文件夹和文件，不同文件夹下可以使用相同的文件名，此时，文件夹就扮演着命名空间的角色，这个原理应用到程序设计领域就是命名空间的概念。\n### 1.1 命名空间的作用\n在 PHP 中，命名空间用来解决在编写类库或应用程序时创建可重用的代码如类或函数式碰到的两类问题：\n1. 用户编写的代码与 PHP 内部（或第三方）的类/函数/常量之间的名字冲突。\n2. 为很长的标识名称（通常是为了缓解第一类问题而定义的）创建一个别名（或简短）的名称，提高代码可读性。\n   总的来说，PHP 命名空间提供了一种将相关的类、函数和常量组合到一起的途径\n   **Note：**名为 PHP 或 php 命名的空间，以及这些名字开头的命名空间（例如 PHP\\Classes）被保留用作语言内核使用，而不应该在用户空间代码中使用。\n\n\n## 第2节 定义命名空间\n### 语法说明\n* 虽然任意合法的 PHP 代码都可以包含在命名空间中，但只有**类（包括抽象类和 traits）、接口、函数和常量**这些类型的代码受命名空间的影响。\n* 命名空间通过关键字*namespace*来声明。如果一个文件中包含命名空间，它必须在其他所有代码之前声明命名空间。除了*declare*语句之外.  \n```php\n<?php\n	namespace MyProject;\n	\n	const CONNECT_OK = 1;\n	class Connection { /* ... */ }\n	function connect(){ /* ... */ }\n?>\n```\n* 除了 declare 关键以外（用于定义源文件编码方式的 declare 语句），所有其他**非PHP代码包括空白字符**也不能出现在命名空间的声明之前。  \n* \n  ```php\n  <html>\n  <?php \n  namespace MyProject; //Fatal error: Namespace declaration statement has to be the very first statement in...\n  ?>\n  ```\n  \n```\n* 注释是可以放在 namespace 关键字之前的  \n* \n​```php\n<?php\n	// here we go\n	/*\n	 * here we go \n	 */\n	 \n	 \n	 namespace MyProject;\n	 class Bar { /*...*/ }\n?>\n```\n* 另外，与 PHP 其他的语言特征不同，同一个命名空间可以定义在多个文件中，即允许将同一个命名空间的内容分割存放在不同的文件中\n* **Note：**命名空间不要使用 PHP 关键字\n\n## 第3节 定义子命名空间\n与目录和文件的关系很像，PHP 命名空间也允许指定层次化的命名空间的名称。因此，命名空间的名字可以使用分层次的方法定义：\n\n```php\n<?php \n	namespace MyProject \\ Sub \\ Level;\n	\n	const CONNECT_OK = 1;\n	class Connection { /*...*/ }\n	function connect(){ /*...*/ }\n?>\n```\n\n## 第4节 在同一个文件中定义多个命名空间\n**在实际编程实践中，非常不提倡在同一个文件中定义多个命名空间。这种方式的主要用于将多个 PHP 脚本合并在同一个文件中**\n* 语法1：简单组合语法**（不推荐）**\n\n```php\n<?php\n	namespace MyProject;\n	\n	const CONNECT_OK = 1;\n	class Connection{}\n	function connect(){}\n	\n	namespace AnotherProject;\n	const CONNECT_OK = 1;\n	class Connection{}\n	function connect(){}\n?>\n```\n\n* 语法2：大括号语法**（推荐）**，除了开始的 declare 语句外，命名空间的括号外不得使用任何 PHP 代码。\n\n```php\n<?php\n	declare( encoding = \'UTF-8\');\n	namespace MyProject{\n		// code...\n	}\n	\n	namespace AnotherProject{\n		// code...\n	}\n?>\n```\n\n* 将全局的非命名空间中的代码与命名空间中的代码组合在一起，只能使用大括号形式的语法。全局代码必须用一个不带名称的 namespace 语句加上大括号括起来：\n\n```php\n<?php \n	namespace MyProject {\n		// code...\n	}\n	\n	namespace {\n		// gloal code...\n	}\n?>\n```\n\n## 第5节 使用命名空间：基础\n### 5.1 PHP 命名空间访问原理\n与文件系统类似，也有相对路径和绝对路径的说法\n1. 非限定名称，或不包含前缀的类名称。如$a=new foo();或者 foo::staticmethod(); 则被解析为currentnamespace\\foo.如果使用 foo 的代码是全局的，不包含在任何命名空间中的代码，则 foo 会被解析为 foo。\n   **Note：**如果命名空间中的函数或常量未定义，则该非限定的函数名称或常量名称就会被解析为全局函数名或常量名。\n2. 限定名称，或包含前缀的名称，例如$a = new subnamespace\\foo(); 或 subnamespace\\foo::staticmethod();如果当前的命名空间是 currentnamespace，则 foo 被解析为 currentnamespace\\foo。如果使用 foo 的代码是全局的，不包含在任何命名空间中的代码，foo 会被解析为 subnamespace\\foo.\n3. 完全限定名称，或包含了全局前缀操作符的名称。$a = new \\currentnamespace\\foo(); 或\\currentnamespace\\foo::staticmethod(); \n4. 在访问任意全局类、函数或常量、都可以使用完全限定名称，例如\\strlen() 或 \\Exception 或 \\INI_ALL\n\nfile.php\n\n```php\n<?php\nnamespace  Foo \\ Bar \\ subnamespace ;\n\nconst  FOO  =  1 ;\nfunction  foo () {}\nclass  foo\n{\n    static function  staticmethod () {}\n}\n?>\n```\n\nfile2.php\n\n```php\n<?php\nnamespace  Foo \\ Bar ;\ninclude  \'file1.php\' ;\n\nconst  FOO  =  2 ;\nfunction  foo () {}\nclass  foo\n{\n    static function  staticmethod () {}\n}\n\n/* 非限定名称 */\nfoo ();  // 解析为 Foo\\Bar\\foo resolves to function Foo\\Bar\\foo\nfoo :: staticmethod ();  // 解析为类 Foo\\Bar\\foo的静态方法staticmethod。resolves to class Foo\\Bar\\foo, method staticmethod\necho  FOO ;  // resolves to constant Foo\\Bar\\FOO\n\n/* 限定名称 */\nsubnamespace \\ foo ();  // 解析为函数 Foo\\Bar\\subnamespace\\foo\nsubnamespace \\ foo :: staticmethod ();  // 解析为类 Foo\\Bar\\subnamespace\\foo,\n                                  // 以及类的方法 staticmethod\necho  subnamespace \\ FOO ;  // 解析为常量 Foo\\Bar\\subnamespace\\FOO\n                                  \n/* 完全限定名称 */\n\\ Foo \\ Bar \\ foo ();  // 解析为函数 Foo\\Bar\\foo\n\\ Foo \\ Bar \\ foo :: staticmethod ();  // 解析为类 Foo\\Bar\\foo, 以及类的方法 staticmethod\necho \\ Foo \\ Bar \\ FOO ;  // 解析为常量 Foo\\Bar\\FOO\n?>\n\n```\n\nfile3.php\n\n```php\n<?php\nnamespace  Foo ;\n\nfunction  strlen () {}\nconst  INI_ALL  =  3 ;\nclass  Exception  {}\n\n$a  = \\ strlen ( \'hi\' );  // 调用全局函数strlen\n$b  = \\ INI_ALL ;  // 访问全局常量 INI_ALL\n$c  = new \\ Exception ( \'error\' );  // 实例化全局类 Exception\n?>\n```\n\n## 第6节 命名空间和动态语言特征\n当使用动态类名、动态函数名、动态常量名访问命名空间元素时时，即使在命名空间内使用在已经定义的类、函数或常量，必须书写完全限定名称，否则访问的是全局命名空间\n\nexample1.php\n\n```php\n<?php\n/* 动态访问元素 */\nclass classname {\n    function __construct()\n    {\n        echo __METHOD__, \"\\n\";\n    }\n}\n\nfunction funcname(){\n    echo __FUNCTION__, \"\\n\";\n}\n\nconst constname = \"global\";\n\n$a = \'classname\';\n$obj = new $a; // prints classname::__construct\n$b = \'funcname\';\n$b(); // prints funcname;\necho constant(\"constname\"), \"\\n\";\n```\n\nexample2.php\n\n```php\n<?php\nnamespace  namespacename ;\nclass  classname\n{\n    function  __construct ()\n    {\n        echo  __METHOD__ , \"\\n\" ;\n    }\n}\nfunction  funcname ()\n{\n    echo  __FUNCTION__ , \"\\n\" ;\n}\nconst  constname  =  \"namespaced\" ;\n\ninclude  \'example1.php\' ;\n\n$a  =  \'classname\' ;\n$obj  = new  $a ;  // prints classname::__construct\n$b  =  \'funcname\' ;\n$b ();  // prints funcname\necho  constant ( \'constname\' ),  \"\\n\" ;  // prints global\n\n/* note that if using double quotes, \"\\\\namespacename\\\\classname\" must be used */\n$a  =  \'\\namespacename\\classname\' ;\n$obj  = new  $a ;  // prints namespacename\\classname::__construct\n$a  =  \'namespacename\\classname\' ;\n$obj  = new  $a ;  // also prints namespacename\\classname::__construct\n$b  =  \'namespacename\\funcname\' ;\n$b ();  // prints namespacename\\funcname\n$b  =  \'\\namespacename\\funcname\' ;\n$b ();  // also prints namespacename\\funcname\necho  constant ( \'\\namespacename\\constname\' ),  \"\\n\" ;  // prints namespaced\necho  constant ( \'namespacename\\constname\' ),  \"\\n\" ;  // also prints namespaced\n?>\n\n```\n\n## 第7节 namespace 关键字和 \\_\\_NAMESPACE__常量\n### 7.1 \\_\\_MAMESPACE__ \n该魔术常量的值是包含当前命名空间名称的字符串，在全局命名空间则是一个空字符串。\n### 7.2 \\_\\_MAMESPACE__ 用法\n\\_\\_MAMESPACE\\_\\_ 在创建动态名称时很有用\n\n```php\n<?php\n	namespace MyProject;\n	/*\n	 * 使用动态类名实例化当前命名空间下的类的对象\n	 */\n	function get ($classname){\n		$a = __NAMESPACE__ . \'\\\\\' . $classname;\n		returen new $a;\n	}\n?>\n```\n\n### 7.3 namespace 操作符\n可用来显式的访问当前命名空间或子命名空间中的元素。它等价于类中的 self 操作符\n\n```php\n<?php\nnamespace  MyProject ;\n\nuse  blah \\ blah  as  mine ;  // see \"Using namespaces: importing/aliasing\"\n\nblah \\ mine ();  // calls function blah\\blah\\mine()\nnamespace\\ blah \\ mine ();  // calls function MyProject\\blah\\mine()\n\nnamespace\\ func ();  // calls function MyProject\\func()\nnamespace\\ sub \\ func ();  // calls function MyProject\\sub\\func()\nnamespace\\ cname :: method ();  // calls static method \"method\" of class MyProject\\cname\n$a  = new namespace\\ sub \\ cname ();  // instantiates object of class MyProject\\sub\\cname\n$b  = namespace\\ CONSTANT ;  // assigns value of constant MyProject\\CONSTANT to $b\n?>\n```\n\n## 第8节 使用命名空间：别名/导入\n允许通过别名引用或导入外部的完全限定名称，是命名空间的一个重要特征。这有点类似于在类 unix 文件系统中可以创建对其它的文件或目录的符号连接。\n所有支持命名空间的PHP版本支持三种别名或导入方式：为类名称使用别名、为接口使用别名或为命名空间名称使用别名。PHP 5.6开始允许导入函数或常量或者为它们设置别名。\n**别名是通过操作符 use 来实现的**\n\n```php\n<?php\nnamespace  foo ;\nuse  My \\ Full \\ Classname  as  Another ;\n\n// 下面的例子与 use My\\Full\\NSname as NSname 相同\nuse  My \\ Full \\ NSname ;\n\n// 导入一个全局类\nuse  ArrayObject ;\n\n// importing a function (PHP 5.6+)\nuse function  My \\ Full \\ functionName ;\n\n// aliasing a function (PHP 5.6+)\nuse function  My \\ Full \\ functionName  as  func ;\n\n// importing a constant (PHP 5.6+)\nuse const  My \\ Full \\ CONSTANT ;\n\n$obj  = new namespace\\ Another ;  // 实例化 foo\\Another 对象\n$obj  = new  Another ;  // 实例化 My\\Full\\Classname　对象\nNSname \\ subns \\ func ();  // 调用函数 My\\Full\\NSname\\subns\\func\n$a  = new  ArrayObject (array( 1 ));  // 实例化 ArrayObject 对象\n// 如果不使用 \"use \\ArrayObject\" ，则实例化一个 foo\\ArrayObject 对象\nfunc ();  // calls function My\\Full\\functionName\necho  CONSTANT ;  // echoes the value of My\\Full\\CONSTANT\n?>\n```\n**因为导入的名称必须是完全限定的，不会根据当前的命名空间作相对解析，所以前导反斜杠是不必要也不推荐的**\n\n为了简化操作，PHP还支持在一行中使用多个use语句\n\n```php\n<?php\nuse  My \\ Full \\ Classname  as  Another ,  My \\ Full \\ NSname ;\n\n$obj  = new  Another ;  // 实例化 My\\Full\\Classname 对象\nNSname \\ subns \\ func ();  // 调用函数 My\\Full\\NSname\\subns\\func\n?>\n```\n\n导入操作是在编译执行的，但动态的类名称、函数名称或常量名称则不是。\n\n```php\n<?php\nuse  My \\ Full \\ Classname  as  Another ,  My \\ Full \\ NSname ;\n\n$obj  = new  Another ;  // 实例化一个 My\\Full\\Classname 对象\n$a  =  \'Another\' ;\n$obj  = new  $a ;       // 实际化一个 Another 对象\n?>\n```\n\n另外，导入操作只影响非限定名称和限定名称。完全限定名称由于是确定的，故不受导入的影响。\n\n```php\n<?php\nuse  My \\ Full \\ Classname  as  Another ,  My \\ Full \\ NSname ;\n\n$obj  = new  Another ;  // instantiates object of class My\\Full\\Classname\n$obj  = new \\ Another ;  // instantiates object of class Another\n$obj  = new  Another \\ thing ;  // instantiates object of class My\\Full\\Classname\\thing\n$obj  = new \\ Another \\ thing ;  // instantiates object of class Another\\thing\n?>\n```\n\nThe use keyword must be declared in the outermost scope of a file (the global scope) or inside namespace declarations. This is because the importing is done at compile time and not runtime, so it cannot be block scoped. The following example will show an illegal use of the use keyword:\n\n```php\n<?php\nnamespace  Languages ;\n\nclass  Greenlandic\n{\n    use  Languages \\ Danish ;\n\n    ...\n}\n?>\n```\n\n**Note: Importing rules are per file basis, meaning included files will NOT inherit the parent file\'s importing rules.**\n## 第9节 全局空间\n如果没有定义任何命名空间，所有的类与函数的定义都是在全局空间，与 PHP 引入命名空间概念前一样。在名称前加上前缀 \\ 表示该名称是全局空间中的名称，即使该名称位于其它的命名空间中时也是如此。\n\n```php\n<?php\nnamespace  A \\ B \\ C ;\n\n/* 这个函数是 A\\B\\C\\fopen */\nfunction  fopen () { \n      /* ... */\n      $f  = \\ fopen (...);  // 调用全局的fopen函数\n      return  $f ;\n} \n?>\n```\n\n## 第10节 使用命名空间：后备全局函数/常量\n在一个命名空间中，当 PHP 遇到一个非限定的类、函数或常量名称时，它使用不同的优先策略来解析该名称。类名称总是解析到当前命名空间中的名称。因此在访问系统内部或不包含在命名空间中的类名称时，必须使用完全限定名称，例如：\n\n```php\n<?php\nnamespace  A \\ B \\ C ;\nclass  Exception  extends \\ Exception  {}\n\n$a  = new  Exception ( \'hi\' );  // $a 是类 A\\B\\C\\Exception 的一个对象\n$b  = new \\ Exception ( \'hi\' );  // $b 是类 Exception 的一个对象\n\n$c  = new  ArrayObject ;  // 致命错误, 找不到 A\\B\\C\\ArrayObject 类\n?>\n```\n\n对于函数和常量来说，如果当前命名空间中不存在该函数或常量，PHP 会退而使用全局空间中的函数或常量。\n\n```php\n<?php\nnamespace  A \\ B \\ C ;\n\nconst  E_ERROR  =  45 ;\nfunction  strlen ( $str )\n{\n    return \\ strlen ( $str ) -  1 ;\n}\n\necho  E_ERROR ,  \"\\n\" ;  // 输出 \"45\"\necho  INI_ALL ,  \"\\n\" ;  // 输出 \"7\" - 使用全局常量 INI_ALL\n\necho  strlen ( \'hi\' ),  \"\\n\" ;  // 输出 \"1\"\nif ( is_array ( \'hi\' )) {  // 输出 \"is not array\"\n     echo  \"is array\\n\" ;\n} else {\n    echo  \"is not array\\n\" ;\n}\n?>\n```\n## 第11节 名称解析规则\n### 11.1 命名空间名称定义\n1. 非限定名称 Unqualified name  \n   名称中不包含命名空间分隔符的标识符，例如 Foo\n2. 限定名称 Qualified name  \n   名称中罕有命名空间分隔符的标识， 例如 Foo \\ Bar\n3. 完全限定名称 Fully qualified name  \n   名称中包含命名空间分隔符，并以命名空间分隔符开始的标识，例如 \\Foo\\ Bar, namespace \\ Foo 也是一个完全限定名称\n\n### 11.2 名称解析遵循下列规则\n1. 对完全限定名称的函数，类和常量的调用在编译时解析。例如 new \\A\\B 解析为类 A\\B。\n2. 所有的非限定名称和限定名称（非完全限定名称）根据当前的导入规则在编译时进行转换。例如，如果命名空间 A\\B\\C 被导入为 C，那么对 C\\D\\e() 的调用就会被转换为 A\\B\\C\\D\\e()。\n3. 在命名空间内部，所有的没有根据导入规则转换的限定名称均会在其前面加上当前的命名空间名称。例如，在命名空间 A\\B 内部调用 C\\D\\e()，则 C\\D\\e() 会被转换为 A\\B\\C\\D\\e() 。\n4. 非限定类名根据当前的导入规则在编译时转换（用全名代替短的导入名称）。例如，如果命名空间 A\\B\\C 导入为C，则 new C() 被转换为 new A\\B\\C() 。\n5. 在命名空间内部（例如A\\B），对非限定名称的函数调用是在运行时解析的。例如对函数 foo() 的调用是这样解析的：\n   在当前命名空间中查找名为 A\\B\\foo() 的函数\n   尝试查找并调用 全局(global) 空间中的函数 foo()。\n6. 在命名空间（例如A\\B）内部对非限定名称或限定名称类（非完全限定名称）的调用是在运行时解析的。下面是调用 new C() 及 new D\\E() 的解析过程：   \n   new C()的解析:\n7. 在当前命名空间中查找A\\B\\C类。\n8. 尝试自动装载类A\\B\\C。  \n\n new D\\E()的解析:   \n\n  1. 在类名称前面加上当前命名空间名称变成：A\\B\\D\\E，然后查找该类。\n  2. 尝试自动装载类 A\\B\\D\\E。  \n\n为了引用全局命名空间中的全局类，必须使用完全限定名称 new \\C()。 \n\n```php\n<?php\nnamespace  A ;\nuse  B \\ D ,  C \\ E  as  F ;\n\n// 函数调用\n\nfoo ();       // 首先尝试调用定义在命名空间\"A\"中的函数foo()\n            // 再尝试调用全局函数 \"foo\"\n\n\\ foo ();      // 调用全局空间函数 \"foo\" \n\nmy \\ foo ();    // 调用定义在命名空间\"A\\my\"中函数 \"foo\" \n\nF ();         // 首先尝试调用定义在命名空间\"A\"中的函数 \"F\" \n            // 再尝试调用全局函数 \"F\"\n\n// 类引用\n\nnew  B ();     // 创建命名空间 \"A\" 中定义的类 \"B\" 的一个对象\n            // 如果未找到，则尝试自动装载类 \"A\\B\"\n\nnew  D ();     // 使用导入规则，创建命名空间 \"B\" 中定义的类 \"D\" 的一个对象\n            // 如果未找到，则尝试自动装载类 \"B\\D\"\n\nnew  F ();     // 使用导入规则，创建命名空间 \"C\" 中定义的类 \"E\" 的一个对象\n            // 如果未找到，则尝试自动装载类 \"C\\E\"\n\nnew \\ B ();    // 创建定义在全局空间中的类 \"B\" 的一个对象\n            // 如果未发现，则尝试自动装载类 \"B\"\n\nnew \\ D ();    // 创建定义在全局空间中的类 \"D\" 的一个对象\n            // 如果未发现，则尝试自动装载类 \"D\"\n\nnew \\ F ();    // 创建定义在全局空间中的类 \"F\" 的一个对象\n            // 如果未发现，则尝试自动装载类 \"F\"\n\n// 调用另一个命名空间中的静态方法或命名空间函数\n\nB \\ foo ();     // 调用命名空间 \"A\\B\" 中函数 \"foo\"\n\nB :: foo ();    // 调用命名空间 \"A\" 中定义的类 \"B\" 的 \"foo\" 方法\n            // 如果未找到类 \"A\\B\" ，则尝试自动装载类 \"A\\B\"\n\nD :: foo ();    // 使用导入规则，调用命名空间 \"B\" 中定义的类 \"D\" 的 \"foo\" 方法\n            // 如果类 \"B\\D\" 未找到，则尝试自动装载类 \"B\\D\"\n\n\\ B \\ foo ();    // 调用命名空间 \"B\" 中的函数 \"foo\" \n\n\\ B :: foo ();   // 调用全局空间中的类 \"B\" 的 \"foo\" 方法\n            // 如果类 \"B\" 未找到，则尝试自动装载类 \"B\"\n\n// 当前命名空间中的静态方法或函数\n\nA \\ B :: foo ();    // 调用命名空间 \"A\\A\" 中定义的类 \"B\" 的 \"foo\" 方法\n              // 如果类 \"A\\A\\B\" 未找到，则尝试自动装载类 \"A\\A\\B\"\n\n\\ A \\ B :: foo ();   // 调用命名空间 \"A\\B\" 中定义的类 \"B\" 的 \"foo\" 方法\n              // 如果类 \"A\\B\" 未找到，则尝试自动装载类 \"A\\B\"\n?>\n```',0,0,0,0),(14,6,'02 MVC','= 模型的处理\n\n业务逻辑的处理，最终都是通过操作数据库完成的\n\n\n== 模型类\n\nmvc 分层中，典型的模型是：\n\n每个模型是一个对象，一个模型对象负责完成数据库中一个表的操作\n\n.AR: active record\n****\n一个对象对应一张表\n\n一个方法对应一行记录\n\n一个属性对应一个字段\n****\n\n\nimage::Model.png[]\n\n此时，针对某个表的操作，应该封装到相应的模型类中\n\n例如，操作 match 表，就会有以下的模型\n\n[source,php]\n.MatchModel.php\n----\n<?php\n\nclass MatchModel{\n    \n}\n----\n\n完成比赛列表，在获得数据时，应该通过实例化该模型类的对象，调用其获得数据的方法\n\n[source,php]\n.MatchModel.class.php\n----\n<?php\n\n/**\n * Class MatchModel 操作 select_match 表的模型类\n */\nclass MatchModel{\n\n    /**\n     * 模型的获得比赛列表的方法\n     * @return array 比赛列表\n     */\n    public function matchList(){\n        // 获得比赛数据\n        mysql_connect(\'127.0.0.1\',\'root\',\'root\');\n        mysql_query(\'set names utf8\');\n        mysql_select_db(\'test01\');\n        \n        $sql = \'select match_time, s1.stu_name as P1 , match_result, s2.stu_name as P2 \n	from select_match as m \n	left join select_student as s1 on m.player_1 = s1.id\n	left join select_student as s2 on m.player_2=s2.id\';\n\n        $result = mysql_query($sql);\n        $sequence = 0;\n        while($row=mysql_fetch_assoc($result)){\n            $sequence ++;\n            $rows[] = $row;\n        }\n\n        return $rows;\n    }\n}\n----\n\n使用该模型类：\n\n实例化该类对象，调用该方法\n\n[source,php]\n.match_controller.php\n----\n<?php \n\n// 调用模型\n// 引入模型类文件\nrequire \'./MatchModel.php\';\n// 实例化\n$model_match = new MatchModel;\n// 得到所有比赛信息\n$rows = $model_match->matchList();\n\n// 调用视图展示结果\ninclude \'./templates/match_list.html\';\n----\n\n举一反三：班级列表\n\n步骤一：增加控制器文件，并完成向 模型和视图发出命令\n\n[source,php]\n.class_controller.php\n----\n<?php\n\n// 调用模型\nrequire \'./ClassModel.class.php\';\n$model_class = new ClassModel;\n$rows = $model_class->getList();\n\n// 调用视图显示数据\nrequire \'./templates/class_view.html\';\n----\n\n步骤二：建立一个 ClassModel模型类操作 select_class 表，并增加一个getList() 方法，返回班级数据\n\n[source,php]\n.ClassModel.class.php\n----\n<?php\n\n/**\n * Class ClassModel 操作 select_class 表的模型类\n */\nclass ClassModel{\n    /**\n     * @return array 返回班级列表数据\n     */\n    public function getList(){\n        mysql_connect(\'127.0.0.1\',\'root\',\'root\');\n        mysql_query(\'set names utf8\');\n        mysql_select_db(\'test01\');\n        $sql = \'select c.*, count(s.id) as count from select_class as c left join select_student as s on c.id = s.class_id group by c.id\';\n\n        $result = mysql_query($sql);\n        $rows = array();\n        while($row = mysql_fetch_assoc($result)){\n            $rows[] = $row;\n        }\n\n        return $rows;\n    }\n}\n----\n\n\n步骤三：增加一个视图模板\n\n[source,html]\n.class_view.html\n----\n<!doctype html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"./style.css\">\n    <title>班级信息列表</title>\n</head>\n<body>\n<h2>班级信息列表</h2>\n<table>\n    <tr>\n        <th>序号</th>\n        <th>班级名称</th>\n        <th>教室</th>\n        <th>班级人数</th>\n    </tr>\n\n    <?php\n\n$sequence = 0;\nforeach($rows as $row):\n	$sequence ++;?>\n    <tr>\n        <td><?php echo $sequence;?></td>\n        <td><?php echo $row[\'class_name\'];?></td>\n        <td><?php echo $row[\'classrom\'];?></td>\n        <td><?php echo $row[\'count\'];?></td>\n    </tr>\n\n    <?php endforeach;?>\n</table>\n</body>\n</html>\n----\n\n== 基础模型类\n\n模型的公共操作的提取\n\n增加一个模型基础类\n\nimage::basic_model.png[]\n\n[source,php]\n.Model.class.php\n----\n<?php\n\n/**\n * Class Model 模型的基础类\n */\nclass Model{\n\n}\n----\n\n所有的模型类都应该继承自该基础类\n\n手动载入基础模型类文件，并删除连接数据代码\n\n[source,php]\n.MatchMode.class.php\n----\n<?php\n\nrequire_once \'./Model.class.php\';\n/**\n * Class MatchModel 操作 select_match 表的模型类\n */\nclass MatchModel extends Model{\n\n    /**\n     * 模型的获得比赛列表的方法\n     * @return array 比赛列表\n     */\n    public function matchList(){\n        // 获得比赛数据\n\n        $sql = \'select match_time, s1.stu_name as P1 , match_result, s2.stu_name as P2 \n	from select_match as m \n	left join select_student as s1 on m.player_1 = s1.id\n	left join select_student as s2 on m.player_2=s2.id\';\n\n        $result = mysql_query($sql);\n        $sequence = 0;\n        while($row=mysql_fetch_assoc($result)){\n            $sequence ++;\n            $rows[] = $row;\n        }\n\n        return $rows;\n    }\n}\n----\n\n应该在实例化模型对象时，就完成数据库连接\n\n在继承模型类中增加构造方法，被子类所继承，需要在构造方法中完成数据库连接。\n\n[source,php]\n.Model.class.php\n----\n<?php\n\n/**\n * Class Model 模型的基础类\n */\nclass Model{\n    /**\n     * Model constructor.\n     */\n    public function __construc(){\n        $this->initLink();\n    }\n\n    /**\n     * 初始化数据库的连接\n     */\n\n    protected function initLink(){\n        mysql_connect(\'127.0.0.1\',\'root\',\'root\');\n        mysql_query(\'set names utf8\');\n        mysql_select_db(\'test01\');\n    }\n}\n----\n\n此时，一旦实例化就完成数据库连接工作\n\n\n== 模型类利用 MySQLDB 操作数据库\n\nimage::basic_mode_update.png[]\n\n[source,php]\n.Model.class.php\n----\n<?php\n\n/**\n * Class Model 模型的基础类\n */\nclass Model{\n    protected $db;\n    /**\n     * Model constructor.\n     */\n    public function __construct(){\n        $this->initLink();\n    }\n\n    /**\n     * 初始化数据库的连接\n     */\n\n    protected function initLink(){\n        require \'./MySQLDB.class.php\';\n        $params = array(\'dbname\'=>\'test01\');\n        $this->db = MySQLDB::getInstance($params);\n    }\n}\n----\n\n此时，在基础模型类中，初始化数据库连接，其实就是实例化 MySQLDB 类的对象，保存到当前的对象的 $db 属性上\n\n具体的模型中，如果需要执行 sql，就应该使用模型对象的 $db 属性中保存的 MySQLDB 类对象来完成\n\n[source,php]\n.MatchModel.class.php\n----\n<?php\n\nrequire_once \'./Model.class.php\';\n/**\n * Class MatchModel 操作 select_match 表的模型类\n */\nclass MatchModel extends Model{\n\n    /**\n     * 模型的获得比赛列表的方法\n     * @return array 比赛列表\n     */\n    public function matchList(){\n        // 获得比赛数据\n\n        $sql = \'select match_time, s1.stu_name as P1 , match_result, s2.stu_name as P2 \n	from select_match as m \n	left join select_student as s1 on m.player_1 = s1.id\n	left join select_student as s2 on m.player_2=s2.id\';\n\n        $rows = $this->db->fetchAll($sql);\n        return $rows;\n    }\n}\n----\n\n[source,php]\n.ClassModel.class.php\n----\n<?php\n\nrequire_once \'./Model.class.php\';\n/**\n * Class ClassModel 操作 select_class 表的模型类\n */\nclass ClassModel extends Model{\n    /**\n     * @return array 返回班级列表数据\n     */\n    public function getList(){\n\n        $sql = \'select c.*, count(s.id) as count from select_class as c left join select_student as s on c.id = s.class_id group by c.id\';\n\n        $rows = $this->db->fetchAll($sql);\n        return $rows;\n    }\n}\n----\n\n',0,0,0,0),(16,4,'系统基础',NULL,1,1499268161,1499268161,0),(17,4,'系统管理',NULL,1,1499268172,1499268172,0),(18,4,'服务安全及服务管理',NULL,1,1499268185,1499268185,0),(19,4,'Shell 脚本',NULL,1,1499268207,1499268207,0),(20,4,'MySQL 数据库',NULL,1,1499268234,1499268234,0),(21,4,'集群',NULL,1,1499268245,1499268245,0),(22,4,'分布式',NULL,1,1499268253,1499268253,0),(23,4,'虚拟化技术',NULL,1,1499268310,1499268310,0),(24,4,'Openstack',NULL,1,1499268496,1499268496,0),(25,4,'运维工具',NULL,1,1499268530,1499268530,0),(26,4,'监控工具',NULL,1,1499268688,1499268688,0),(27,4,'大数据处理',NULL,1,1499268737,1499268737,0),(28,4,'Docker',NULL,1,1499268862,1499268862,0),(29,4,'Python',NULL,1,1499268903,1499268903,0),(30,16,'01 虚拟机','# VMware Workstation的使用：\n\n\n\n* 现代计算机设备的组成部分：\n\n    运算器、控制器、存储器、输入设备、输出设备\n	\n    CPU\n	\n    bus：总线\n	\n    memory: 编址存储设备\n	\n\n    read ahead\n\n    IO: 与外部部件交互\n	\n    磁盘：\n	\n    网卡：\n\n\n* 虚拟机：虚拟计算机\n\n  用软件模拟计算机\n\n  VMware Workstation、Virtualbox',0,1499272157,1499272157,0),(31,16,'02 操作系统概述','# 操作系统概述\n\n## CPU：运算器、控制器\n\n* CPU指令，指令集；\n* 特权指令：OS运行特权指令；\n* 普通指令：\n* 程序员：\n\n## OS: Operating System\n\n什么是 操作系统\n\n* 软件程序\n* 通用目的\n  * 硬件驱动\n  * 进程管理\n  * 内存管理\n  * 网络管理\n  * 安全管理\n\n## System Call\n\n Syscall：系统调用\n\n## 编程层次：\n\n* 硬件规格：hardware specifiacation\n* 系统调用：\n* 库调用：library call\n\n## UI: 用户接口\n\n* GUI: Graphic User Interface\n* CLI: Command Line Interface\n\n* ABI: Application Binary Interface\n* API：Application Programming Interface\n\n##  CPU架构类型：\n\n* x86\n* x64\n* arm\n* m68000, m68k\n* power\n* powerpc\n* ultrasparc\n* alpha\n* 安腾\n\n## OS 类型\n\n* Windows\n* Linux：\n   Linus --> Linux\n\n  GNU/Linux\n\n* Unix：\n* System （Bell Lab）\n   * AIX （IBM）\n   * Solaris (SUN)\n   * HP-UX (HP)\n* BSD: （BSRG）Berkeley System Distribution\n   * NetBSD\n   * OpenBSD\n   * FreeBSD\n\n## GNU\n\n* MIT：Richard Stallman\n* GNU: GNU is Not Unix；\n* GPL：General Public License',0,1499588362,1499588362,0),(32,16,'03 什么是 Linux','# 什么是 Linux\n\n## 计算机的基础知识：\n\nCPU, memory, I/O\n\n程序运行模式：\n* 用户空间：user space, us\n* 内核空间：system space\n\nPOS: Portable Operating System\n* POSIX\n* API: 编程接口；\n\n## 运行程序格式：\n* Windows: EXE, dll(dynamic link library)\n* Linux: ELF, so(shared object)\n\n* 程序：指令+数据\n  * 指令：只读\n  * 数据：读写\n\n* 程序：算法+数据结构\n  * 库调用，系统调用：允许被调用的程序；\n  * malloc(), free()\n\n## 编程语言：\n* 汇编语言：微码编程\n  * 系统中某些与硬件相关的特有代码、驱动程序开发；\n* 高级语言C, C++：\n  * 系统级应用、驱动程序\n* 高级应用java, python, php：\n  * 应用程序\n\n## Linux的发行版：unix-like\n\n* slackware:\n  * suse\n   * opensuse\n* debian:\n  * ubuntu\n   * mint\n* redhat：\n  * rhel: redhat enterprise linux\n    * 每18个月发行一个新版本\n  * CentOS：兼容rhel的格式\n  * fedora：每6个月发行一个新版本\n\n* ArchLinux\n* Gentoo\n* LFS: Linux From scratch\n\n* Android: kernel+busybox+java虚拟机\n\n## 开原协议\n\n* GNU: GPLv2, GPLv3, LGPL(lesser)\n  * A: 1000, GPL,\n  * B: 20000, 20\n* Apache: apache\n* BSD: bsd\n* MIT\n\n\n## 问题\n\n* 问题1：CentOS和Linux是什么关系？CentOS和RHEL是什么关系？\n* 问题2：各种开源协议的具体细节？\n  GPL, LGPL, Apache, BSD\n\n## 程序包管理器：\n\n* rpm:\n   RHEL, Fedora, S.u.S.E, CentOS\n* dpt:\n   Debian, Ubuntu\n\n## 自由软件：\n\n  自由使用；自由学习和修改；自由分发；自由创建衍生版；\n\n## Linux的哲学思想：\n1. 一切皆文件；\n  把几乎所有资源，包括硬件设备都组织为文件格式；\n2. 由众多单一目的小程序组成；一个程序只实现一个功能，而且要做好；\n  组合小程序完成复杂任务；\n3. 尽量避免跟用户交互；\n  目标：实现脚本编程，以自动完成某些功能；\n4. 使用纯文本文件保存配置信息；\n  目标：一款使用的文本编程器即能完成系统配置工作；\n\n## 如何获取CentOS的发行版：\n1. http://mirrors.aliyun.com\n2. http://mirrors.sohu.com\n3. http://mirrors.163.com\n\n## 登录：\n* root/mageedu\n\n* `# startx &`\n',0,1499604578,1499604578,0),(33,16,'04 终端 命令 文件系统','# 终端 命令 文件系统\n\n## 终端：\n\n用户与主机交互，必然用到的设备；\n\n* 物理终端：直接接入本机的显示器和键盘设备；/dev/console\n\n* 虚拟终端：附加在物理终端之上的以软件方式虚拟实现的终端，CentOS 6默认启动6个虚拟终端\n* Ctrl+Alt+F#: [1,6]\n* 图形终端：附加在物理终端之上的以软件方式虚拟实现的终端，但额外会提供桌面环境；\n* 设备文件路径：/dev/tty#\n* 模拟终端：\n* 图形界面下打开的命令行接口，基于ssh协议或telnet协议等远程打开的界面\n* 设备文件：/dev/pts/#    [0,oo)\n\n查看当前的终端设备：tty\n\n## 交互式接口：\n\n启动终端后，在终端设备附加一个交互式应用程序\n​		\n* GUI：\n* X protocol, window manager, desktop\n* Desktop:\n  * GNOME (C, gtk)\n  * KDE   (C++, qt)\n  * XFCE  (轻量级桌面)\n* CLI：\n* shell程序：\n  * sh (bourn)\n  * csh \n  * tcsh\n  * ksh (korn)\n  * bash (bourn again shell), GPL\n  * zsh \n\n显示当前使用的shell：\n\n`# echo ${SHELL}`\n\n显示当前系统使用的所有shell：\n`# cat /etc/shells`\n\n## 命令提示符：prompt\n\n```shell\n[root@localhost ~]#\n [root@localhost ~]：PS1\n prompt：\n  管理员：#\n  普通用户：$\n```\n\n## 命令：\n输入命令，回车：\n  提请shell程序找到键入命令所对应的可执行程序或代码，并由其分析后提交给内核分配资源将其运行起来；\n\n表现为一个或多个进程；\n\n在shell中可执行的命令有两类：\n\n* 内建命令：由shell自带的，而且通过某命令形式提供；\n* 外部命令：在当前系统的某文件系统路径下有对应的可执行程序文件；\n\n`which，whereis`\n\n\n区别内部或外部命令：\n`# type COMMAND`\n\n## 运行命令：\n\n命令格式：\n\n`COMMAND [OPTIONS...] [ARGUMENTS...]`\n\n* 选项：用于启用或关闭命令的某个或某些功能；\n* 短选项：`-c, 例如：-l, -h`\n  多个短选项可命令使用，`例如-l -h, 可写作-lh；`\n* 长选项：`--word，例如：--long, --human-readable`\n* 参数：命令的作用对象\n  向命令提供数据；\n\n注意：\n1. 多选项，以及多参数和命令之间都应该使用空白字符分隔\n2. 取消命令执行：Ctrl+c\n\n## 文件系统：\n`C:\\Program files\\office11\\word\\word.exe`\n\n`/etc/sysconfig/network-scripts/ifcfg-eth0`\n\n文件有两类数据：\n* 元数据：metadata\n* 数据：data\n\n1. 文件名严格区分字符大小写；file1, File1, FILE1是不同的文件；\n2. 文件名可使用除/以外的任意字符，不建议使用特殊字符；\n3. /: 根目录，路径分隔符；\n4. 文件名长度最长不能超过255个字符；\n5. 所以.开头的文件，均为隐藏文件；\n\n## 路径：\n* 绝对路径：从根目录起始的路径；\n* 相对路径：对当前位置起始的路径；\n\n\n当前位置的表示方式：\n1. ./： ./sysconfig/network-scripts\n2. 省略上述符号: sysconfig/network-scripts\n3. ..：表示当前目录的上一级目录\n\n当前目录：current directory, 也称作working directory；\n\npwd: printing working directory\n\n\nLSB: Linux Standard Base\n\n命令总结：ls, cd, type, tty, cat, which, whereis, pwd, echo\n\n命令：\n1. 文件系统相关：\n    1.1. 目录管理\n    1.2. 文件管理\n    1.3. 文件查看\n    1.4. 文件编辑\n2. 系统管理相关：',0,1499617047,1499617047,0);
/*!40000 ALTER TABLE `notes` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2017-07-11 15:37:06
